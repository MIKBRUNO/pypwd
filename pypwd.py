import sys
import os

import _scrypt
from scrypt.scrypt import hash
import bcrypt
import rsa
from Crypto.Cipher import AES

from getpass import getpass
from pyperclip import copy
import json

import unicodedata as uni


help_text = \
            'python pypwd.py [action] [modifier]\n' \
            'or\n' \
            'pypwd [action] [modifier]\n\n' \
            'Actions:\n' \
            '\t-h, --help: shows this message\n' \
            '\t-l, --list: shows list of available accounts that have any when used\n' \
            '\t-sr, --save-read-password: saves or reads password from file\n' \
            '\t-g, --gen-password: generates password\n' \
            '\t-sg, --save-generated: saves generated password to a file\n' \
            'Modifiers:\n' \
            '\t[-k filepath], [--keys-file filepath]: sets special keys file path\n' \
            '\t[-p filepath], [--pass-file filepath]: sets special pass file path\n' \
            '\t-loc, --local-key-pass-file: sets path for key and pass to execution path\n' \
            '\t[-c aA1/~], [--characters-specification aA1/~]: specifies types of characters to use\n' \
            '\t[-n <int>], [--number <int>]: number of symbols? default is 30'


def get_path() -> str:
    """
    Returns path where stored keys and encrypted passwords.
    :return: Path can be %AppData%/Local/.pass/ if its running on Windows or /etc/.pass/ if on Linux
    """
    if sys.platform == 'win32':
        try:
            os.mkdir('c:/Users/' + os.getlogin() + '/AppData/Local/.pass/')
        except FileExistsError:
            pass
        path = 'c:/Users/' + os.getlogin() + '/AppData/Local/.pass/'
    elif sys.platform == 'linux' or sys.platform == 'linux2':
        path = '/etc/.pass/'
    else:
        raise OSError('not supported OS')
    return path


def make_symbol_in_range(sym: int, ranges: list):
    for boundary in ranges:
        if (sym % 0x7f) in range(boundary[0], boundary[1]):
            bt = sym % 0x7f
            bt = bt.to_bytes(2, 'big')
            ch = bt.decode('UTF-16BE')
            return ch
    n = (sym >> 4) % len(ranges)
    boundary = ranges[n]
    for j in range(0xf):
        sym += 1
        for i in range(boundary[0], boundary[1]):
            if sym & 0x0f == i & 0x0f:
                bt = i
                bt = bt.to_bytes(2, 'big')
                ch = bt.decode('UTF-16BE')
                return ch


def gen_password(account: str, master_pass: str, using_symbols: str = '~', number: int = 30) -> str:
    """
    Generates password from account name and master password
    :param account: just name of account you want to generate password
    :param master_pass: master password you only know
    :param using_symbols: string specifies using symbols see help_text
    :param number: number of characters in password
    :return: generated password

    UTF help: https://en.wikipedia.org/wiki/List_of_Unicode_characters; https://unicode-table.com
    UTF characters:
    ~ all printable characters
    / 20-2F, 3A-40, 5B-60, 7B-7E: punctuation
    a 61-7A: latin lowercase
    A 41-5A: latin uppercase
    1 30-39: digits
    """
    account = account.lower()
    account = int.from_bytes(account.encode(), 'big')  # translates str to int to make XOR
    master_pass = int.from_bytes(master_pass.encode(), 'little')  # translates to int for same reason
    ex_ = account ^ master_pass  # XOR to bind account and master password into one value
    ex_ = ex_.to_bytes(ex_.bit_length()//8+1, 'little')  # returning XORed value to bytes
    salt = hash(ex_, b'$2b$20$aRZ.6PMpc9dZpNnSjgWje.')  # hashing with well-known salt
    ex_ = hash(ex_, salt)  # hashing with itself's salt
    ex = ''
    # writing generated bytes to str, decode bytes if its possible else write as hex
    if using_symbols.find('~') != -1:
        for i in ex_[:number]:
            b = i
            # if i & 0b10000000 == 0b10000000:  # see UTF-8 octets
            #     b = ((0b11000000 + ((i & 0b11000000) >> 6)) << 8) + 0b10000000 + (i & 0b00111111)
            bt = b.to_bytes(2, 'big')
            ch = bt.decode('UTF-16BE')
            while not ch.isprintable():
                b += 16
                bt = b.to_bytes(2, 'big')
                ch = bt.decode('UTF-16BE')
            ex += ch
    else:
        available_chars = []
        if using_symbols.find('a') != -1:
            available_chars.append((0x61, 0x7a+1))
        if using_symbols.find('A') != -1:
            available_chars.append((0x41, 0x5a + 1))
        if using_symbols.find('1') != -1:
            available_chars.append((0x30, 0x39 + 1))
        if using_symbols.find('/') != -1:
            available_chars.extend([(0x20, 0x2f + 1), (0x3a, 0x40 + 1), (0x5b, 0x60 + 1), (0x7b, 0x7e + 1)])
        for i in ex_[:number]:
            b = i
            ex += make_symbol_in_range(b, available_chars)
    return ex[:number]  # result is large so getting only first 30 symbols


def get_rsa_keys(keys_path: str) -> (rsa.PublicKey, rsa.PrivateKey):
    """
    Reading RSA public and private key from keys.pem file at get_path() dir if there it is
    else it will be generated
    :param keys_path: default None will be replaced with default path, you can change path
    :return: RSA Public and Private (Secret) key pair
    """
    try:  # if file exists just read and decrypt this
        with open(keys_path, 'rb') as pem:
            k = pem.read()
            password = getpass('Passphrase: ')  # special password to read and write keys to file
            salt = k[-29:]  # last 29 bytes are salt see except statement
            nonce = k[-45:-29]  # 16 bytes after encrypted keys and before salt is special AES nonce
            pass_aes_key = hash(password.encode(), salt, buflen=16)  # AES key generates only from passphrase
            cipher = AES.new(pass_aes_key, AES.MODE_EAX, nonce=nonce)  # here using key and nonce
            res = cipher.decrypt(k[-len(k):-45])  # decrypting only keys part of file
            try:  # if decrypting ended successful
                pk = rsa.PublicKey.load_pkcs1(res)
                sk = rsa.PrivateKey.load_pkcs1(res)
                return pk, sk
            except ValueError:  # incorrect can be only passphrase or file was corrupted
                print('Incorrect passphrase or corrupted keys file')
                quit(1)
    except FileNotFoundError:  # if file doesn't exist
        # generating keys
        pk, sk = rsa.newkeys(1024)
        pk_ = pk.save_pkcs1()
        sk_ = sk.save_pkcs1()
        k = pk_ + b'\n' + sk_  # join keys into one file text
        print('Now we\'re gonna gen new keys for you it\'s at ' + keys_path)
        password = getpass('New passphrase, remember it: ')
        salt = bcrypt.gensalt(8)  # generating salt
        # hash passphrase and salt to a bytes with len 16 so it can be AES key
        pass_aes_key = hash(password.encode(), salt, buflen=16)
        cipher = AES.new(pass_aes_key, AES.MODE_EAX)
        with open(keys_path, 'wb') as pem:
            k = cipher.encrypt(k)  # encrypt keys
            k += cipher.nonce + salt  # add 16 bytes of nonce and 29 (don't know why) bytes of salt
            pem.write(k)
        return pk, sk


def get_passes(private_key: rsa.PrivateKey, _pass_path: str) -> dict:
    """
    Reading or making new dict of passes
    :param private_key: RSA Private key to decrypt pass file
    :param _pass_path: path to pass file
    :return: dict of passes
    """
    try:
        with open(_pass_path, 'rb') as f:
            r = f.read()
        if not r:
            return {}
        else:
            try:
                res = b''
                for i in range(len(r)//128):
                    part = r[128*i:128*(i+1)]
                    part = rsa.decrypt(part, private_key)
                    res += part
                return json.loads(res)
            except json.decoder.JSONDecodeError:
                print('Corrupted pass file')
                quit(1)
    except FileNotFoundError:
        return {}


def write_passes(passes_to_write: dict, _pass_path: str, _public_key: rsa.PublicKey) -> None:
    """
    Just writing all passes to a file with encryption
    :param passes_to_write: dict of passes
    :param _pass_path: path to a pass file
    :param _public_key: RSA Public key to encrypt
    """
    w = json.dumps(passes_to_write)
    w = w.encode()
    with open(_pass_path, 'wb') as f:
        to_write = b''
        for i in range(len(w)//100 + 1):
            part = w[100*i:100*(i+1)]
            part = rsa.encrypt(part, _public_key)
            to_write += part
        f.write(to_write)


def ask_user(msg: str = 'Are you sure to continue') -> bool:
    """
    Just print msg and wait for user response that can be True(Y) or False(n)
    :param msg: Message to ask
    :return: return user answer
    """
    response = input(msg + ' [Y/n]')
    response.lower()
    if response == 'y' or response == 'yes':
        return True
    elif response == 'n' or response == 'no':
        return False
    else:
        return ask_user('Print \'Y\' or \'n\' only')


MODE_GEN = 1 << 0
MODE_SAVE = 1 << 1
MODE_LIST = 1 << 2


if __name__ == '__main__':
    mode = 0
    pass_path = None
    key_path = None
    symbols = '~'
    num = 30
    if len(sys.argv) > 1:
        argv = sys.argv[1:]

        for argi in range(len(argv)):  # only one flag
            if argv[argi] == '-h' or argv[argi] == '--help':
                # write help message
                print(help_text)
                quit()

        for argi in range(len(argv)):  # flags of file destination
            if argv[argi] == '-k' or argv[argi] == '--keys-file':
                # read next arg for keys path
                try:
                    if argv[argi + 1][0] != '-':
                        key_path = argv[argi + 1]
                        # try:
                        if os.path.lexists(os.path.dirname(key_path)):
                            # f = open(argv[argi + 1], 'wb')
                            # f.close()
                            argi += 1
                        # except (FileNotFoundError, OSError):
                        else:
                            print('Path not found')
                            quit(1)
                    else:
                        print('File path not specified, must be [' + argv[argi], '<file_path>]')
                        quit(1)
                except IndexError:
                    print('File path not specified, must be [' + argv[argi], '<file_path>]')
                    quit(1)

            elif argv[argi] == '-p' or argv[argi] == '--pass-file':
                # read next arg for pass file path
                try:
                    if argv[argi + 1][0] != '-':
                        pass_path = argv[argi + 1]
                        # try:
                        if os.path.lexists(os.path.dirname(pass_path)):
                            # f = open(argv[argi + 1], 'wb')
                            # f.close()
                            argi += 1
                        # except (FileNotFoundError, OSError):
                        else:
                            print('Path not found')
                            quit(1)
                    else:
                        print('File path not specified, must be [' + argv[argi], '<file_path>]')
                        quit(1)
                except IndexError:
                    print('File path not specified, must be [' + argv[argi], '<file_path>]')
                    quit(1)

            elif argv[argi] == '-loc' or argv[argi] == '--local-key-pass-file':
                # search and write keys and passes to a exec path
                if pass_path or key_path:
                    if ask_user('Files are already specified do you want to replace them with local?'):
                        pass_path = 'pass.ww3'
                        key_path = 'keys.pem'
                else:
                    pass_path = 'pass.ww3'
                    key_path = 'keys.pem'

        for argi in range(len(argv)):  # action flags
            if not mode & MODE_LIST:
                if argv[argi] == '-g' or argv[argi] == '--gen-password':
                    # generating password
                    mode |= MODE_GEN

                elif argv[argi] == '-sr' or argv[argi] == '--save-read-password':
                    # save password
                    mode |= MODE_SAVE

                elif argv[argi] == '-sg' or argv[argi] == '--save-generated':
                    # generate and save it to pass file
                    mode |= MODE_SAVE | MODE_GEN
            elif argv[argi] in ['-g', '--gen-password', '-sr', '--save-read-password', '-sg', '--save-generated']:
                print('Can\'t combine \'--list\' and \'' + argv[argi] + "'")
                quit(1)

            if argv[argi] == '-l' or argv[argi] == '--list':
                if not mode & (MODE_GEN | MODE_SAVE):
                    # print a list of accounts
                    mode = MODE_LIST
                else:
                    print('Can\'t combine \'--gen-password\' or \'--save-password\' or both with \'' + argv[argi] + "'")
                    quit(1)

        for argi in range(len(argv)):  # characters sepcification
            if argv[argi] == '-c' or argv[argi] == '--characters-specification':
                if not mode & MODE_GEN:
                    print('Modifier works only with generation password')
                    quit(1)
                try:
                    if argv[argi + 1][0] != '-':
                        argi += 1
                    else:
                        print('Argument must be specified for [-n number]')
                        quit(1)
                    for i in argv[argi]:
                        if 'aA1/~'.find(i) == -1:
                            print('Wrong argument ' + i)
                            quit(1)
                    symbols = argv[argi]
                except IndexError:
                    print('Argument must be specified for [-c aA1/~]')
                    quit(1)

            if argv[argi] == '-n' or argv[argi] == '--number':
                if not mode & MODE_GEN:
                    print('Modifier works only with generation password')
                    quit(1)
                try:
                    if argv[argi + 1][0] != '-':
                        argi += 1
                    else:
                        print('Argument must be specified for [-n number]')
                        quit(1)
                    try:
                        num = int(argv[argi])
                    except ValueError:
                        print('Wrong argument ' + argv[argi])
                        quit(1)
                except IndexError:
                    print('Argument must be specified for [-c aA1/~]')
                    quit(1)

    else:
        if ask_user('Do you want generate your password?'):
            mode |= MODE_GEN
            if ask_user('Do you want save it?'):
                mode |= MODE_SAVE
            if not ask_user('Do you want to use all characters?'):
                symbols = ''
                if ask_user('Do you want to append digits?'):
                    symbols += '1'
                if ask_user('Do you want to append latin letters?'):
                    if ask_user('Do you want to append lowercase letters?'):
                        symbols += 'a'
                    if ask_user('Do you want to use uppercase letters?'):
                        symbols += 'A'
                if ask_user('Do you want to append punctuation signs?'):
                    symbols += '/'
            if ask_user('Do you want to specify number of characters?'):
                try:
                    num = int(input('Input number of characters '))
                except ValueError:
                    print('Wrong input')
                    quit(1)
        elif ask_user('Do you want to save/load it?'):
            mode |= MODE_SAVE
        else:
            mode = MODE_LIST

        if ask_user('Do you want to specify key file?'):
            key_path = input('Input key file path: ')
        if ask_user('Do you want to specify pass file?'):
            pass_path = input('Input pass file path: ')
        if not pass_path and not key_path and ask_user('Do you want to use local files?'):
            pass_path = 'pass.ww3'
            key_path = 'keys.pem'

    if mode == 0:
        print('Mode must be specified add -s, -g, -sg, or -l')
        quit(1)

    if not pass_path:
        pass_path = os.path.join(get_path(), 'pass.ww3')
    if not key_path:
        key_path = os.path.join(get_path(), 'keys.pem')

    print('Opening key file...')
    public_key, secret_key = get_rsa_keys(key_path)
    print('Successfully opened!')
    print('Opening passwords file..')
    passes = get_passes(secret_key, pass_path)
    print('Successfully opened!')

    if mode & (MODE_SAVE | MODE_GEN):
        account_name = input('Input account: ')

        if not mode & MODE_GEN and mode & MODE_SAVE:
            if account_name in passes:
                if passes[account_name] == 'gen':
                    mode = MODE_GEN
                else:
                    copy(passes[account_name])
            else:
                new_pass = getpass('Input your new pass: ')
                passes[account_name] = new_pass

        if mode & MODE_GEN:
            master_key = getpass('Input your secret master password: ')
            gened_password = gen_password(account_name, master_key, symbols, num)
            copy(gened_password)
            if mode & MODE_SAVE:
                passes[account_name] = gened_password
            else:
                passes[account_name] = 'gen'

    if mode & MODE_LIST:
        for i in passes:
            print(i)

    write_passes(passes, pass_path, public_key)
